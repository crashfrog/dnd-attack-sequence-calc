<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D&D Attack Roller</title>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect } = React;
    
    // Lucide icons as inline SVG components
    const Swords = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"></polyline>
        <line x1="13" y1="19" x2="19" y2="13"></line>
        <line x1="16" y1="16" x2="20" y2="20"></line>
        <line x1="19" y1="21" x2="21" y2="19"></line>
        <polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5"></polyline>
        <line x1="5" y1="14" x2="9" y2="18"></line>
        <line x1="7" y1="17" x2="4" y2="20"></line>
        <line x1="3" y1="19" x2="5" y2="21"></line>
      </svg>
    );
    
    const Settings = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M12 1v6m0 6v6m-9-9h6m6 0h6"></path>
        <path d="M4.22 4.22l4.24 4.24m7.08 0l4.24-4.24M4.22 19.78l4.24-4.24m7.08 0l4.24 4.24"></path>
      </svg>
    );
    
    const Dices = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <path d="M7 7h.01M17 7h.01M7 17h.01M17 17h.01M12 12h.01"></path>
      </svg>
    );
    
    const Plus = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    );
    
    const Trash2 = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        <line x1="10" y1="11" x2="10" y2="17"></line>
        <line x1="14" y1="11" x2="14" y2="17"></line>
      </svg>
    );
    
    const User = ({ size = 24, className = "" }) => (
      <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
        <circle cx="12" cy="7" r="4"></circle>
      </svg>
    );

    function DnDAttackRoller() {
      const [characters, setCharacters] = useState([]);
      const [activeCharIndex, setActiveCharIndex] = useState(0);
      const [showConfig, setShowConfig] = useState(true);
      const [results, setResults] = useState(null);
      const [attackMode, setAttackMode] = useState('normal');

      useEffect(() => {
        const loadCharacters = () => {
          try {
            const stored = localStorage.getItem('dnd-characters');
            if (stored) {
              const chars = JSON.parse(stored);
              // Migrate old format to new format
              const migratedChars = chars.map(char => {
                if (!char.attackTypes) {
                  return {
                    name: char.name,
                    attackTypes: [
                      {
                        name: 'Attack',
                        count: char.numAttacks || 4,
                        bonus: char.attackBonus || 10,
                        damageDice: char.damageDice || '1d8+5',
                        critRange: char.critRange || 20,
                        smiteDice: '',
                        brutalCritDice: char.critExtraDice || ''
                      }
                    ]
                  };
                }
                return {
                  ...char,
                  attackTypes: char.attackTypes.map(at => ({
                    ...at,
                    smiteDice: at.smiteDice ?? '',
                    brutalCritDice: at.brutalCritDice ?? at.critExtraDice ?? ''
                  }))
                };
              });
              setCharacters(migratedChars);
            } else {
              const defaultChar = {
                name: 'Character 1',
                attackTypes: [
                  {
                    name: 'Attack',
                    count: 4,
                    bonus: 10,
                    damageDice: '1d8+5',
                    critRange: 20,
                    smiteDice: '',
                    brutalCritDice: '1d10+2d8'
                  }
                ]
              };
              setCharacters([defaultChar]);
            }
          } catch (error) {
            const defaultChar = {
              name: 'Character 1',
              attackTypes: [
                {
                  name: 'Attack',
                  count: 4,
                  bonus: 10,
                  damageDice: '1d8+5',
                  critRange: 20,
                  smiteDice: '',
                  brutalCritDice: '1d10+2d8'
                }
              ]
            };
            setCharacters([defaultChar]);
          }
        };
        loadCharacters();
      }, []);

      useEffect(() => {
        if (characters.length > 0) {
          try {
            localStorage.setItem('dnd-characters', JSON.stringify(characters));
          } catch (error) {
            console.error('Failed to save characters:', error);
          }
        }
      }, [characters]);

      const activeChar = characters[activeCharIndex] || null;

      const updateActiveChar = (updates) => {
        const newChars = [...characters];
        newChars[activeCharIndex] = { ...newChars[activeCharIndex], ...updates };
        setCharacters(newChars);
      };

      const addCharacter = () => {
        const newChar = {
          name: `Character ${characters.length + 1}`,
          attackTypes: [
            {
              name: 'Attack',
              count: 4,
              bonus: 10,
              damageDice: '1d8+5',
              critRange: 20,
              smiteDice: '',
              brutalCritDice: ''
            }
          ]
        };
        setCharacters([...characters, newChar]);
        setActiveCharIndex(characters.length);
        setShowConfig(true);
      };

      const deleteCharacter = (index) => {
        if (characters.length === 1) return;
        const newChars = characters.filter((_, i) => i !== index);
        setCharacters(newChars);
        if (activeCharIndex >= newChars.length) {
          setActiveCharIndex(newChars.length - 1);
        }
        setResults(null);
      };

      const parseDice = (diceStr) => {
        if (!diceStr) return { dice: [], flat: 0 };
        const parts = diceStr.split('+').map(p => p.trim());
        const dice = [];
        let flat = 0;
        
        parts.forEach(part => {
          if (part.includes('d')) {
            const [num, sides] = part.split('d').map(n => parseInt(n));
            dice.push({ num, sides });
          } else {
            flat += parseInt(part) || 0;
          }
        });
        
        return { dice, flat };
      };

      const rollDice = (num, sides) => {
        const rolls = [];
        for (let i = 0; i < num; i++) {
          rolls.push(Math.floor(Math.random() * sides) + 1);
        }
        return rolls;
      };

      const rollDiceTotal = (diceConfig) => {
        return diceConfig.reduce((sum, { num, sides }) => {
          const rolls = rollDice(num, sides);
          return sum + rolls.reduce((a, b) => a + b, 0);
        }, 0);
      };

      const rollDamage = (diceStr) => {
        const { dice, flat } = parseDice(diceStr);
        return flat + rollDiceTotal(dice);
      };

      const rollD20 = () => {
        const rollOnce = () => Math.floor(Math.random() * 20) + 1;
        if (attackMode === 'normal') return rollOnce();
        const first = rollOnce();
        const second = rollOnce();
        if (attackMode === 'advantage') return Math.max(first, second);
        return Math.min(first, second);
      };

      const performAttackSequence = () => {
        if (!activeChar) return;
        
        const attacks = [];
        let totalDamage = 0;
        let smiteApplied = false;
        
        // Roll all attacks from all attack types
        activeChar.attackTypes.forEach(attackType => {
          for (let i = 0; i < attackType.count; i++) {
            const attackRoll = rollD20();
            const isMiss = attackRoll === 1;
            const totalAttack = isMiss ? -Infinity : attackRoll + attackType.bonus;
            const isCrit = !isMiss && attackRoll >= attackType.critRange;

            let damage = 0;

            if (!isMiss) {
              const parsedDamage = parseDice(attackType.damageDice);
              damage = parsedDamage.flat + rollDiceTotal(parsedDamage.dice);

              if (isCrit) {
                damage += rollDiceTotal(parsedDamage.dice);

                if (attackType.brutalCritDice) {
                  damage += rollDamage(attackType.brutalCritDice);
                }

                if (attackType.smiteDice && !smiteApplied) {
                  damage += rollDamage(attackType.smiteDice);
                  smiteApplied = true;
                }
              }

              totalDamage += damage;
            }

            attacks.push({
              typeIndex: activeChar.attackTypes.indexOf(attackType),
              typeName: attackType.name,
              attackRoll,
              totalAttack,
              damage,
              isCrit,
              isMiss
            });
          }
        });
        
         attacks.sort((a, b) => {
           if (a.isMiss && b.isMiss) return 0;
           if (a.isMiss) return 1;
           if (b.isMiss) return -1;
           return a.totalAttack - b.totalAttack;
         });
        
        const thresholds = [];
        let cumulativeDamage = totalDamage;
        
        attacks.forEach(attack => {
          if (!attack.isMiss) {
            thresholds.push({
              ac: attack.totalAttack,
              damage: cumulativeDamage,
              isCrit: attack.isCrit,
              typeName: attack.typeName,
              isNat20: attack.attackRoll === 20
            });
            cumulativeDamage -= attack.damage;
          }
        });
        
        setResults({ attacks, thresholds, totalDamage });
        setShowConfig(false);
      };

      const formatOutput = () => {
        if (!results) return '';
        
        const parts = results.thresholds.map((t, i) => {
          const critNote = t.isCrit ? ' (crit)' : '';
          const typeNote = t.typeName ? ` [${t.typeName}]` : '';
          if (t.isNat20) {
            return `${t.damage} damage (nat 20 auto-hit)${typeNote}${critNote}`;
          }
          return `${t.damage} damage if ${t.ac} hits${typeNote}${critNote}`;
        });
        
        return parts.join(', ');
      };

      const addAttackType = () => {
        const newAttackTypes = [...activeChar.attackTypes];
        newAttackTypes.push({
          name: `Attack Type ${newAttackTypes.length + 1}`,
          count: 1,
          bonus: 0,
          damageDice: '1d8',
          critRange: 20,
          smiteDice: '',
          brutalCritDice: ''
        });
        updateActiveChar({ attackTypes: newAttackTypes });
      };

      const removeAttackType = (index) => {
        if (activeChar.attackTypes.length === 1) return;
        const newAttackTypes = activeChar.attackTypes.filter((_, i) => i !== index);
        updateActiveChar({ attackTypes: newAttackTypes });
      };

      const updateAttackType = (index, updates) => {
        const newAttackTypes = [...activeChar.attackTypes];
        newAttackTypes[index] = { ...newAttackTypes[index], ...updates };
        updateActiveChar({ attackTypes: newAttackTypes });
      };

      if (!activeChar) return <div className="min-h-screen bg-gradient-to-br from-red-900 via-gray-900 to-gray-800 flex items-center justify-center text-white">Loading...</div>;

      return (
        <div className="min-h-screen bg-gradient-to-br from-red-900 via-gray-900 to-gray-800 p-4">
          <div className="max-w-2xl mx-auto">
            <div className="bg-gray-800 rounded-lg shadow-2xl p-6 mb-4">
              <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-2">
                  <Swords className="text-red-500" size={32} />
                  <h1 className="text-2xl font-bold text-white">Attack Roller</h1>
                </div>
                <button
                  onClick={() => setShowConfig(!showConfig)}
                  className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
                >
                  <Settings className="text-gray-300" size={24} />
                </button>
              </div>

              <div className="mb-6">
                <div className="flex gap-2 mb-2 flex-wrap">
                  {characters.map((char, i) => (
                    <div key={i} className="flex items-center gap-1">
                      <button
                        onClick={() => {
                          setActiveCharIndex(i);
                          setResults(null);
                        }}
                        className={`px-3 py-2 rounded-lg transition-colors flex items-center gap-2 ${
                          i === activeCharIndex
                            ? 'bg-red-600 text-white'
                            : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                        }`}
                      >
                        <User size={16} />
                        {char.name}
                      </button>
                      {characters.length > 1 && (
                        <button
                          onClick={() => deleteCharacter(i)}
                          className="p-2 bg-gray-700 hover:bg-red-600 rounded-lg transition-colors"
                        >
                          <Trash2 size={16} className="text-gray-400" />
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    onClick={addCharacter}
                    className="px-3 py-2 bg-green-700 hover:bg-green-600 rounded-lg transition-colors flex items-center gap-2 text-white"
                  >
                    <Plus size={16} />
                    Add Character
                  </button>
                </div>
                <div className="flex flex-col gap-2 p-3 bg-gray-800 rounded-lg border border-gray-700">
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium text-gray-200">Attack Roll Mode</span>
                    <span className="text-xs text-gray-400">Applies to all attacks this round</span>
                  </div>
                  <div className="flex gap-2 flex-wrap">
                    {[
                      { key: 'normal', label: 'Normal' },
                      { key: 'advantage', label: 'Advantage' },
                      { key: 'disadvantage', label: 'Disadvantage' }
                    ].map(mode => (
                      <button
                        key={mode.key}
                        onClick={() => setAttackMode(mode.key)}
                        className={`px-3 py-2 rounded-md text-sm font-semibold transition-colors ${
                          attackMode === mode.key
                            ? 'bg-red-600 text-white'
                            : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
                        }`}
                      >
                        {mode.label}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {showConfig && (
                <div className="space-y-4 mb-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-300 mb-1">
                      Character Name
                    </label>
                    <input
                      type="text"
                      value={activeChar.name}
                      onChange={(e) => updateActiveChar({ name: e.target.value })}
                      className="w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-red-500 focus:outline-none"
                    />
                  </div>

                  <div className="border-t border-gray-600 pt-4">
                    <div className="flex items-center justify-between mb-4">
                      <h3 className="text-lg font-semibold text-white">Attack Types</h3>
                      <button
                        onClick={addAttackType}
                        className="px-2 py-1 bg-green-700 hover:bg-green-600 rounded text-white text-sm flex items-center gap-1"
                      >
                        <Plus size={14} />
                        Add Attack Type
                      </button>
                    </div>

                    {activeChar.attackTypes.map((attackType, typeIndex) => (
                      <div key={typeIndex} className="mb-6 p-4 bg-gray-700 rounded-lg">
                        <div className="flex items-center justify-between mb-3">
                          <input
                            type="text"
                            value={attackType.name}
                            onChange={(e) => updateAttackType(typeIndex, { name: e.target.value })}
                            className="flex-1 px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm font-medium"
                          />
                          {activeChar.attackTypes.length > 1 && (
                            <button
                              onClick={() => removeAttackType(typeIndex)}
                              className="ml-2 p-1 bg-red-700 hover:bg-red-600 rounded transition-colors"
                            >
                              <Trash2 size={14} className="text-white" />
                            </button>
                          )}
                        </div>

                        <div className="grid grid-cols-2 gap-3 mb-3">
                          <div>
                            <label className="block text-xs font-medium text-gray-300 mb-1">
                              # of Attacks
                            </label>
                            <input
                              type="number"
                              min="1"
                              value={attackType.count}
                              onChange={(e) => updateAttackType(typeIndex, { count: parseInt(e.target.value) })}
                              className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium text-gray-300 mb-1">
                              Attack Bonus
                            </label>
                            <input
                              type="number"
                              value={attackType.bonus}
                              onChange={(e) => updateAttackType(typeIndex, { bonus: parseInt(e.target.value) })}
                              className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                            />
                          </div>
                        </div>

                        <div className="mb-3">
                          <label className="block text-xs font-medium text-gray-300 mb-1">
                            Damage Dice (e.g., "1d8+5")
                          </label>
                          <input
                            type="text"
                            value={attackType.damageDice}
                            onChange={(e) => updateAttackType(typeIndex, { damageDice: e.target.value })}
                            className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                          />
                        </div>

                        <div className="grid grid-cols-2 gap-3">
                          <div>
                            <label className="block text-xs font-medium text-gray-300 mb-1">
                              Crit Range
                            </label>
                            <input
                              type="number"
                              value={attackType.critRange}
                              onChange={(e) => updateAttackType(typeIndex, { critRange: parseInt(e.target.value) })}
                              className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                            />
                          </div>
                          <div>
                            <label className="block text-xs font-medium text-gray-300 mb-1">
                              Brutal Critical Dice (every crit)
                            </label>
                            <input
                              type="text"
                              value={attackType.brutalCritDice}
                              onChange={(e) => updateAttackType(typeIndex, { brutalCritDice: e.target.value })}
                              className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                            />
                          </div>
                        </div>

                        <div className="grid grid-cols-2 gap-3 mt-3">
                          <div className="col-span-2">
                            <label className="block text-xs font-medium text-gray-300 mb-1">
                              Smite Dice (first crit only)
                            </label>
                            <input
                              type="text"
                              value={attackType.smiteDice}
                              onChange={(e) => updateAttackType(typeIndex, { smiteDice: e.target.value })}
                              className="w-full px-2 py-1 bg-gray-600 text-white rounded border border-gray-500 focus:border-red-500 focus:outline-none text-sm"
                            />
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              <button
                onClick={performAttackSequence}
                className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition-colors flex items-center justify-center gap-2"
              >
                <Dices size={20} />
                Roll Attack Sequence
              </button>
            </div>

            {results && (
              <div className="bg-gray-800 rounded-lg shadow-2xl p-6">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-bold text-white">Results for {activeChar.name}</h2>
                  <span className="px-3 py-1 rounded-full text-xs font-semibold bg-gray-700 text-gray-200 border border-gray-600">
                    Mode: {attackMode.charAt(0).toUpperCase() + attackMode.slice(1)}
                  </span>
                </div>
                
                <div className="mb-6 p-4 bg-gray-700 rounded-lg">
                  <h3 className="text-sm font-semibold text-gray-400 mb-3">Individual Attacks</h3>
                  <div className="space-y-2">
                    {results.attacks.map((attack, i) => (
                       <div key={i} className={`flex justify-between text-sm ${attack.isMiss ? 'bg-red-900 bg-opacity-50 p-2 rounded' : ''}`}>
                         <span className={attack.isMiss ? 'text-red-300 font-bold' : attack.isCrit ? 'text-yellow-400 font-bold text-white' : 'text-white'}>
                           Attack {i + 1} <span className="text-gray-400">[{attack.typeName}]</span>: d20={attack.attackRoll}
                           {attack.isMiss ? ' → MISS ✗' : ` → ${attack.totalAttack} to hit${attack.isCrit ? ' ⚡CRIT⚡' : ''}`}
                        </span>
                         <span className={`font-mono ${attack.isMiss ? 'text-red-300' : 'text-white'}`}>{attack.isMiss ? 'miss' : `${attack.damage} dmg`}</span>
                      </div>
                    ))}
                  </div>
                  <div className="mt-4 pt-4 border-t border-gray-600 text-white font-bold">
                    Total Damage: <span className="text-green-400 text-lg">{results.totalDamage}</span>
                  </div>
                </div>

                <div className="p-4 bg-green-900 bg-opacity-30 border-2 border-green-500 rounded-lg">
                  <h3 className="text-sm font-semibold text-green-400 mb-2">DM Summary</h3>
                  <p className="text-white font-mono text-sm leading-relaxed break-words">
                    {formatOutput()}
                  </p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<DnDAttackRoller />, document.getElementById('root'));
  </script>
</body>
</html>
